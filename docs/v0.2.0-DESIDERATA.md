# Gay.jl v0.2.0 Desiderata

## Strong Parallelism Invariance (SPI) as Core Principle

**SPI Guarantee**: The same `(seed, index)` pair produces identical colors regardless of:
- Execution order (sequential, parallel, interleaved)
- Thread count (1 thread, 1000 threads)
- Hardware (CPU, GPU, distributed)
- Time (today, next year, different machine)

This is the fundamental contract that enables deterministic parallel color generation.

### SPI Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Strong Parallelism Invariance (SPI)                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  AXIOM: color(seed, index) = color(seed, index)  ∀ execution context       │
│                                                                             │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐         │
│  │   splitmix64    │    │ SplittableRandom│    │  XOR Fingerprint│         │
│  │   O(1) hash     │    │   Tree splits   │    │   Verification  │         │
│  │   ~2ns/color    │    │   Fork-safe     │    │   CPU = GPU     │         │
│  └────────┬────────┘    └────────┬────────┘    └────────┬────────┘         │
│           │                      │                      │                   │
│           └──────────────────────┼──────────────────────┘                   │
│                                  │                                          │
│                         ┌────────▼────────┐                                 │
│                         │  hash_color()   │                                 │
│                         │  Canonical SPI  │                                 │
│                         │    Function     │                                 │
│                         └────────┬────────┘                                 │
│                                  │                                          │
│    ┌─────────────┬───────────────┼───────────────┬─────────────┐           │
│    ▼             ▼               ▼               ▼             ▼           │
│ ┌──────┐    ┌──────┐       ┌──────────┐    ┌──────┐     ┌──────────┐       │
│ │ CPU  │    │ GPU  │       │ Distrib  │    │ REPL │     │ Serialize│       │
│ │Thread│    │Metal │       │   MPI    │    │Lisp  │     │  JSON    │       │
│ └──────┘    └──────┘       └──────────┘    └──────┘     └──────────┘       │
│                                                                             │
│  VERIFICATION: xor_fingerprint(cpu_colors) == xor_fingerprint(gpu_colors)  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### SPI Primitives (v0.1.0)

| Function | SPI Property | Complexity |
|----------|--------------|------------|
| `splitmix64(x)` | Pure hash, no state | O(1) |
| `hash_color(index, seed)` | Deterministic RGB | O(1) ~2ns |
| `color_at(index, seed)` | Same as above | O(1) |
| `GayInterleaver` | Fork-safe sublattice streams | O(1) per color |
| `xor_fingerprint(colors)` | Verification hash | O(n) |
| `ka_colors!(matrix)` | GPU/CPU identical results | O(n) parallel |

### SPI for v0.2.0: Universal Determinism

Every new integration must preserve SPI:

```julia
# Protocol: Any Colorable type must satisfy SPI
abstract type SPIColorable end

"""
    spi_color(x::SPIColorable, seed::UInt64) -> RGB

SPI-compliant coloring. Must satisfy:
  spi_color(x, s) == spi_color(x, s)  # Deterministic
  parallel_map(x -> spi_color(x, s), xs) == sequential_map(...)  # Order-independent
"""
function spi_color end

# Verification macro
macro verify_spi(expr, seed, n_trials=100)
    quote
        results = [$(esc(expr)) for _ in 1:$(esc(n_trials))]
        @assert all(r == results[1] for r in results) "SPI violation!"
        results[1]
    end
end
```

---

## Interface Evolution & AlgebraicJulia Integration

### Current State (v0.1.0)

```
                    ┌─────────────────────────────────────────────┐
                    │              Gay.jl v0.1.0                  │
                    ├─────────────────────────────────────────────┤
                    │  hash_color(index, seed) → O(1) ~2ns        │
                    │  ka_colors!(matrix)      → GPU/CPU SPMD     │
                    │  ka_color_sums(n)        → Billion-scale    │
                    │  path_probe_color()      → QUIC coloring    │
                    │  abduce()                → Effect → Cause   │
                    └─────────────────────────────────────────────┘
```

### v0.2.0 Goals

1. **Universal Color Experience Integration** - Any system that uses colors should be able to plug in Gay.jl
2. **AlgebraicJulia Ecosystem** - Catlab, ACSets, AlgebraicRewriting compatibility
3. **Functor-Based Interface** - Colors as morphisms in a category

---

## 1. ACSets Integration: ColoredACSets

The AlgebraicJulia ecosystem uses **ACSets** (Attributed C-Sets) as the fundamental data structure. We can extend this to support deterministic coloring.

### Schema: ColoredGraph

```julia
using ACSets, Catlab

# Schema for a colored graph
@present SchColoredGraph(FreeSchema) begin
    V::Ob
    E::Ob
    src::Hom(E, V)
    tgt::Hom(E, V)
    
    # Attribute types
    Color::AttrType
    Seed::AttrType
    
    # Vertex and edge colors computed from deterministic seed
    vcolor::Attr(V, Color)
    ecolor::Attr(E, Color)
    seed::Attr(V, Seed)  # Each vertex carries a seed for its color universe
end

@acset_type ColoredGraph(SchColoredGraph, index=[:src, :tgt])
```

### Gay.jl Integration

```julia
# In src/acsets.jl (new file)
module GayACSets

using ACSets, Catlab
using ..Gay: hash_color, GAY_SEED

export ColoredGraph, ColoredRewriteRule, gay_color_acset!, gay_color_morphism

"""
    gay_color_acset!(g::ACSet; seed=GAY_SEED)

Apply deterministic coloring to all objects in an ACSet.
Each object gets color based on its primary key (row id).
"""
function gay_color_acset!(g::ACSet; seed::UInt64=GAY_SEED)
    # Color all objects that have a color attribute
    for ob in objects(acset_schema(g))
        if has_attr(g, ob, :color)
            for i in parts(g, ob)
                g[i, :color] = hash_color_rgb(i, seed)
            end
        end
    end
    g
end

"""
    ColorFunctor

Functor F: C-Set → Colored C-Set that assigns deterministic colors
based on object indices. Preserves morphism structure.
"""
struct ColorFunctor{S<:UInt64}
    seed::S
end

# Functorial application to morphisms
function (F::ColorFunctor)(f::ACSetMorphism)
    # Colors must be preserved under morphism
    # f(color(x)) = color(f(x)) when same seed
    ...
end

end # module
```

---

## 2. Catlab Categorical Interface

### Colors as a Category

```julia
# The category of colors with seed-indexed palettes
@present SchColorCategory(FreeCategory) begin
    Palette::Ob
    Seed::Ob
    Color::Ob
    
    generate::Hom(Seed, Palette)   # Seed → deterministic palette
    select::Hom(Palette, Color)    # Select color from palette
    mix::Hom(Color ⊗ Color, Color) # Blend colors
end
```

### Natural Transformation: Recoloring

```julia
"""
    recolor(α::Seed → Seed') → NaturalTransformation

Given a seed morphism, produce a natural transformation between
color palettes that preserves structural relationships.
"""
function recolor(seed_from::UInt64, seed_to::UInt64)
    # For each color in palette_from, find corresponding color in palette_to
    # This is an isomorphism when both seeds produce same structure
    ...
end
```

---

## 3. AlgebraicRewriting: ColorPreservingRules

Double-pushout rewriting with color constraints:

```julia
using AlgebraicRewriting

# Rewrite rule that preserves color relationships
struct ColorPreservingRule
    L::ACSet      # Left pattern
    R::ACSet      # Right replacement
    seed::UInt64  # Color seed for consistency
    
    # Constraint: matched colors must satisfy distance predicate
    color_constraint::Function
end

"""
    gay_rewrite(g::ColoredGraph, rule::ColorPreservingRule)

Apply rewriting rule while maintaining color invariants:
1. Matched subgraph colors are preserved
2. New vertices get colors deterministic from creation order
3. XOR fingerprint of graph is trackable
"""
function gay_rewrite(g::ColoredGraph, rule::ColorPreservingRule)
    # Find matches respecting color constraints
    matches = homomorphisms(rule.L, g; 
        predicates=Dict(:vcolor => rule.color_constraint))
    
    # Apply DPO rewriting
    for m in matches
        g = rewrite(rule, m)
        gay_color_acset!(g; seed=rule.seed)
    end
    g
end
```

---

## 4. Tree-Sitter Analysis: Color in Code

Analyze code for color usage patterns and provide intelligent coloring:

```julia
# In src/treesitter.jl (new file)
module GayTreeSitter

using TreeSitter
using ..Gay: hash_color, GAY_SEED

export analyze_color_usage, color_ast, ColoredAST

"""
    ColoredAST

AST node with deterministic color based on:
- Node type hash
- Depth in tree
- Sibling index
- Content hash
"""
struct ColoredAST
    node::TreeSitter.Node
    color::RGB{Float32}
    children::Vector{ColoredAST}
end

"""
    color_ast(source::String, language::Symbol; seed=GAY_SEED)

Parse source code and assign colors to AST nodes deterministically.
Same code → same colors, regardless of when/where parsed.
"""
function color_ast(source::String, language::Symbol; seed::UInt64=GAY_SEED)
    parser = Parser()
    set_language!(parser, language)
    tree = parse(parser, source)
    
    function colorize(node, depth, sibling_idx)
        # Hash combines: node type, depth, sibling position
        type_hash = hash(node.type)
        idx = UInt64(type_hash) ⊻ (UInt64(depth) << 16) ⊻ (UInt64(sibling_idx) << 32)
        color = hash_color_rgb(idx, seed)
        
        children = [colorize(child, depth+1, i) 
                    for (i, child) in enumerate(node.children)]
        
        ColoredAST(node, color, children)
    end
    
    colorize(root(tree), 0, 0)
end

"""
    analyze_color_usage(project_path::String)

Find all color-related patterns in a codebase:
- RGB/HSL/etc literals
- Color library usage (Colors.jl, etc)
- Theme/palette definitions
"""
function analyze_color_usage(project_path::String)
    patterns = Dict{Symbol, Vector{String}}()
    
    # Patterns to search for
    queries = Dict(
        :rgb_literal => "(call (identifier) @fn (#match? @fn \"^RGB\"))",
        :hex_color => "(string) @s (#match? @s \"^#[0-9a-fA-F]{6}\")",
        :hsl_call => "(call (identifier) @fn (#match? @fn \"^HSL\"))",
        :color_import => "(import (identifier) @id (#match? @id \"Colors\"))"
    )
    
    for (name, query) in queries
        patterns[name] = find_all_matches(project_path, query)
    end
    
    patterns
end

end # module
```

---

## 5. Universal Color Experience Protocol

A trait-based interface for any system to integrate Gay.jl colors:

```julia
# In src/protocol.jl (new file)
module GayProtocol

using ..Gay: hash_color, hash_color_rgb, GAY_SEED

export Colorable, colorize, HasColorSeed, color_seed, ColorExperience

"""
    Colorable

Trait for types that can receive deterministic colors.
Implement `colorize(x::T, seed::UInt64)` for your type.
"""
abstract type Colorable end

"""
    HasColorSeed

Trait for types that carry their own color seed.
Implement `color_seed(x::T)::UInt64` to return the seed.
"""
abstract type HasColorSeed end

"""
    ColorExperience{T}

Wrapper that provides a "colored view" of any collection.
"""
struct ColorExperience{T, S<:UInt64}
    data::T
    seed::S
end

# Default protocol: any indexable collection
function Base.getindex(ce::ColorExperience, i::Integer)
    item = ce.data[i]
    color = hash_color_rgb(i, ce.seed)
    (item=item, color=color)
end

# Iteration with colors
function Base.iterate(ce::ColorExperience, state=1)
    if state > length(ce.data)
        return nothing
    end
    item = ce.data[state]
    color = hash_color_rgb(state, ce.seed)
    ((item=item, color=color, index=state), state + 1)
end

"""
    @colorable T

Macro to make a type colorable based on its fields.
"""
macro colorable(T)
    quote
        function Gay.colorize(x::$(esc(T)), seed::UInt64=GAY_SEED)
            # Hash all field values to produce index
            field_hash = hash(x)
            hash_color_rgb(UInt64(field_hash), seed)
        end
    end
end

end # module
```

---

## 6. New Exports for v0.2.0

```julia
# Extended exports in Gay.jl

# ACSets integration
export ColoredGraph, gay_color_acset!, ColorFunctor, recolor

# Tree-sitter analysis  
export ColoredAST, color_ast, analyze_color_usage

# Universal protocol
export Colorable, ColorExperience, @colorable, colorize

# Catlab compatibility
export SchColoredGraph, ColorPreservingRule, gay_rewrite
```

---

## 7. Rimu.jl Integration: Quantum Monte Carlo Coloring

Rimu.jl is a projector quantum Monte Carlo package for many-body quantum systems. Gay.jl can provide deterministic coloring for:

- **Fock states** (BoseFS, FermionFS) - color based on occupation pattern
- **Hamiltonians** - color matrix elements by coupling strength
- **DVec walkers** - visualize population dynamics with consistent colors
- **FCIQMC trajectories** - temporal color evolution for walker populations

### Schema: ColoredFockSpace

```julia
# In src/rimu.jl (new file)
module GayRimu

using Rimu: BoseFS, FermionFS, CompositeFS, AbstractHamiltonian, DVec
using Rimu: diagonal_element, num_occupied_modes, onr
using ..Gay: hash_color, hash_color_rgb, GAY_SEED, splitmix64

export color_fock_state, color_hamiltonian_element, color_dvec
export ColoredWalker, colored_fciqmc_trajectory, render_fock_state

"""
    color_fock_state(fs::BoseFS; seed=GAY_SEED) -> RGB

Deterministic color for a Fock state based on its occupation number representation.
Same state → same color, regardless of when computed.
"""
function color_fock_state(fs::BoseFS; seed::UInt64=GAY_SEED)
    # Hash the occupation pattern
    occ = onr(fs)  # Occupation number representation
    state_hash = reduce(⊻, (splitmix64(UInt64(i) ⊻ UInt64(n) << 32) 
                            for (i, n) in enumerate(occ)); init=seed)
    hash_color_rgb(state_hash, seed)
end

function color_fock_state(fs::FermionFS; seed::UInt64=GAY_SEED)
    # Fermion states: use bit pattern directly
    bits = reinterpret(UInt64, fs.bs)
    hash_color_rgb(bits, seed)
end

function color_fock_state(fs::CompositeFS; seed::UInt64=GAY_SEED)
    # Multi-component: XOR colors of components
    colors = [color_fock_state(component; seed) for component in fs.components]
    # Average RGB values for composite color
    r = sum(c.r for c in colors) / length(colors)
    g = sum(c.g for c in colors) / length(colors)
    b = sum(c.b for c in colors) / length(colors)
    RGB{Float32}(r, g, b)
end

"""
    color_hamiltonian_element(H::AbstractHamiltonian, from, to; seed=GAY_SEED)

Color a Hamiltonian matrix element based on:
- Diagonal: hue from energy value
- Off-diagonal: XOR of state indices → consistent color per coupling
"""
function color_hamiltonian_element(H::AbstractHamiltonian, from, to; seed::UInt64=GAY_SEED)
    if from == to
        # Diagonal: map energy to hue
        E = diagonal_element(H, from)
        # Normalize to [0, 1] using tanh
        normalized = (tanh(E / 10.0) + 1.0) / 2.0
        # Energy → hue (blue=low, red=high)
        return HSL(normalized * 240.0, 0.8, 0.5) |> c -> convert(RGB, c)
    else
        # Off-diagonal: deterministic from state pair
        h1 = hash(from)
        h2 = hash(to)
        idx = UInt64(h1) ⊻ UInt64(h2)
        hash_color_rgb(idx, seed)
    end
end

"""
    ColoredWalker

A walker with its deterministic color for visualization.
"""
struct ColoredWalker{A, C}
    address::A
    coefficient::C
    color::RGB{Float32}
end

"""
    color_dvec(dv::DVec; seed=GAY_SEED) -> Vector{ColoredWalker}

Extract walkers from DVec with deterministic colors for visualization.
"""
function color_dvec(dv::DVec; seed::UInt64=GAY_SEED)
    walkers = ColoredWalker[]
    for (addr, coeff) in pairs(dv)
        color = color_fock_state(addr; seed)
        push!(walkers, ColoredWalker(addr, coeff, color))
    end
    walkers
end

"""
    render_fock_state(fs::BoseFS; width=40) -> String

ANSI-colored rendering of a Fock state.
Each mode gets a color based on its occupation.
"""
function render_fock_state(fs::BoseFS; width::Int=40, seed::UInt64=GAY_SEED)
    occ = onr(fs)
    max_n = maximum(occ)
    
    buf = IOBuffer()
    print(buf, "|")
    
    for (i, n) in enumerate(occ)
        color = hash_color_rgb(UInt64(i) ⊻ (UInt64(n) << 16), seed)
        r = round(Int, color.r * 255)
        g = round(Int, color.g * 255)
        b = round(Int, color.b * 255)
        
        # Bar height proportional to occupation
        bar = "█" ^ max(1, round(Int, n / max_n * 3))
        print(buf, "\e[38;2;$(r);$(g);$(b)m$(n)\e[0m ")
    end
    print(buf, "⟩")
    
    String(take!(buf))
end

"""
    colored_fciqmc_trajectory(sim; seed=GAY_SEED)

Extract FCIQMC trajectory with walker colors for animation.
Returns vector of (step, colored_walkers) tuples.
"""
function colored_fciqmc_trajectory(sim; seed::UInt64=GAY_SEED, skip::Int=10)
    trajectory = []
    for (step, dv) in enumerate(sim.trajectory)
        if step % skip == 0
            walkers = color_dvec(dv; seed)
            push!(trajectory, (step=step, walkers=walkers))
        end
    end
    trajectory
end

# ═══════════════════════════════════════════════════════════════════════════
# Hubbard Model Lattice Visualization
# ═══════════════════════════════════════════════════════════════════════════

"""
    render_hubbard_lattice(H::HubbardReal1D, fs::BoseFS; seed=GAY_SEED)

Render 1D Hubbard lattice with colored sites based on occupation.
"""
function render_hubbard_lattice(H, fs::BoseFS; seed::UInt64=GAY_SEED)
    occ = onr(fs)
    L = length(occ)
    
    buf = IOBuffer()
    
    # Top border
    println(buf, "┌" * ("───┬" ^ (L-1)) * "───┐")
    
    # Site occupations with colors
    print(buf, "│")
    for (i, n) in enumerate(occ)
        color = hash_color_rgb(UInt64(i) ⊻ (UInt64(n) << 16), seed)
        r = round(Int, color.r * 255)
        g = round(Int, color.g * 255)
        b = round(Int, color.b * 255)
        
        # Occupation number centered
        print(buf, " \e[38;2;$(r);$(g);$(b)m$(lpad(n, 1))\e[0m │")
    end
    println(buf)
    
    # Bottom border
    println(buf, "└" * ("───┴" ^ (L-1)) * "───┘")
    
    String(take!(buf))
end

end # module GayRimu
```

### Usage Example

```julia
using Rimu, Gay

# Create Hubbard model
addr = near_uniform(BoseFS{10, 10})
H = HubbardReal1D(addr; u=2.0)

# Color the starting state
color = color_fock_state(addr)
println("State color: ", color)

# Render with ANSI colors
println(render_fock_state(addr))
println(render_hubbard_lattice(H, addr))

# Run FCIQMC and visualize trajectory
prob = ProjectorMonteCarloProblem(H; target_walkers=100, last_step=1000)
sim = solve(prob)

# Get colored walker trajectory for animation
trajectory = colored_fciqmc_trajectory(sim; skip=10)
for frame in trajectory
    println("Step $(frame.step): $(length(frame.walkers)) walkers")
end
```

### FCIQMC Walker Population Heatmap

```julia
"""
    fciqmc_population_heatmap(sim; seed=GAY_SEED)

Generate heatmap data for FCIQMC walker populations over time.
Each Fock state gets consistent color across all timesteps.
"""
function fciqmc_population_heatmap(sim; seed::UInt64=GAY_SEED)
    # Collect all unique addresses
    all_addresses = Set()
    for dv in sim.trajectory
        for addr in keys(dv)
            push!(all_addresses, addr)
        end
    end
    
    # Assign consistent colors
    addr_colors = Dict(addr => color_fock_state(addr; seed) 
                       for addr in all_addresses)
    
    # Build heatmap matrix
    n_steps = length(sim.trajectory)
    n_addrs = length(all_addresses)
    addr_list = collect(all_addresses)
    
    heatmap = zeros(Float32, n_steps, n_addrs)
    for (t, dv) in enumerate(sim.trajectory)
        for (i, addr) in enumerate(addr_list)
            heatmap[t, i] = abs(get(dv, addr, 0.0))
        end
    end
    
    (heatmap=heatmap, addresses=addr_list, colors=addr_colors)
end
```

---

## 8. Lux.jl + Zygote.jl Integration: Neural Network SPI Coloring

Lux.jl provides functional deep learning with explicit state/parameter separation—a perfect match for Gay.jl's SPI architecture. Zygote.jl provides source-to-source AD that we can use to compute gradient colors.

### SPI-Compatible Neural Network Coloring

```julia
# In ext/GayLuxExt.jl
module GayLuxExt

using Lux, Zygote, Random
using Gay: hash_color, hash_color_rgb, GAY_SEED, splitmix64

export color_layer, color_parameters, color_gradients
export ColoredNetwork, render_network_graph, gradient_color_map

# ═══════════════════════════════════════════════════════════════════════════
# Layer Coloring (SPI: same architecture → same color)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_layer(layer::AbstractLuxLayer; seed=GAY_SEED) -> RGB

Deterministic color for a Lux layer based on its structure.
Same layer type + same hyperparameters → same color (SPI).
"""
function color_layer(layer::AbstractLuxLayer; seed::UInt64=GAY_SEED)
    # Hash the layer type and its fields
    type_hash = hash(typeof(layer))
    field_hash = reduce(⊻, (hash(getfield(layer, f)) for f in fieldnames(typeof(layer))); 
                        init=type_hash)
    hash_color_rgb(field_hash, seed)
end

# Specific layer colors for common types
function color_layer(d::Dense; seed::UInt64=GAY_SEED)
    # Dense layers: color based on (in_dims, out_dims, activation)
    idx = UInt64(d.in_dims) ⊻ (UInt64(d.out_dims) << 16) ⊻ hash(d.activation)
    hash_color_rgb(idx, seed)
end

function color_layer(c::Conv; seed::UInt64=GAY_SEED)
    # Conv layers: color based on kernel size, channels
    idx = reduce(⊻, UInt64.(c.kernel_size)) ⊻ 
          (UInt64(c.in_chs) << 16) ⊻ (UInt64(c.out_chs) << 32)
    hash_color_rgb(idx, seed)
end

# ═══════════════════════════════════════════════════════════════════════════
# Parameter Coloring (SPI: same parameter index → same color)
# ═══════════════════════════════════════════════════════════════════════════

"""
    ColoredParameter

A parameter tensor with per-element SPI colors for visualization.
"""
struct ColoredParameter{T, N}
    values::Array{T, N}
    colors::Array{RGB{Float32}, N}
    layer_name::Symbol
end

"""
    color_parameters(ps::NamedTuple; seed=GAY_SEED) -> Dict

Color all parameters in a Lux parameter tree.
Each parameter element gets a deterministic color based on its path + index.
"""
function color_parameters(ps::NamedTuple; seed::UInt64=GAY_SEED, prefix::String="")
    result = Dict{String, ColoredParameter}()
    
    for name in keys(ps)
        full_path = isempty(prefix) ? String(name) : "$(prefix).$(name)"
        param = ps[name]
        
        if param isa NamedTuple
            # Recurse into nested parameters
            merge!(result, color_parameters(param; seed, prefix=full_path))
        elseif param isa AbstractArray
            # Color each element deterministically
            path_hash = hash(full_path)
            colors = similar(param, RGB{Float32})
            for i in eachindex(param)
                idx = UInt64(path_hash) ⊻ UInt64(i)
                colors[i] = hash_color_rgb(idx, seed)
            end
            result[full_path] = ColoredParameter(param, colors, Symbol(name))
        end
    end
    
    result
end

# ═══════════════════════════════════════════════════════════════════════════
# Gradient Coloring with Zygote (SPI + AD)
# ═══════════════════════════════════════════════════════════════════════════

"""
    gradient_color_map(f, ps, x; seed=GAY_SEED)

Compute gradients and assign colors based on gradient magnitude.
High gradient → warm colors (red/orange)
Low gradient → cool colors (blue/green)
Zero gradient → gray

Returns (gradient_values, gradient_colors, loss_value)
"""
function gradient_color_map(f, ps, x; seed::UInt64=GAY_SEED)
    loss, grads = Zygote.withgradient(f, ps, x)
    
    # Flatten gradients for coloring
    colored_grads = Dict{String, ColoredParameter}()
    
    function walk_grads(g::NamedTuple, prefix="")
        for name in keys(g)
            full_path = isempty(prefix) ? String(name) : "$(prefix).$(name)"
            grad = g[name]
            
            if grad isa NamedTuple
                walk_grads(grad, full_path)
            elseif grad isa AbstractArray
                # Color by gradient magnitude (normalized)
                abs_grads = abs.(grad)
                max_grad = maximum(abs_grads)
                max_grad = max_grad > 0 ? max_grad : 1.0
                
                colors = similar(grad, RGB{Float32})
                for i in eachindex(grad)
                    normalized = abs_grads[i] / max_grad
                    # High gradient = red, low = blue
                    hue = (1.0 - normalized) * 240.0  # 240=blue, 0=red
                    colors[i] = convert(RGB, HSL(hue, 0.8, 0.5))
                end
                colored_grads[full_path] = ColoredParameter(grad, colors, Symbol(name))
            end
        end
    end
    
    walk_grads(grads[1])
    (gradients=grads[1], colors=colored_grads, loss=loss)
end

# ═══════════════════════════════════════════════════════════════════════════
# Network Visualization
# ═══════════════════════════════════════════════════════════════════════════

"""
    ColoredNetwork

A Lux model with SPI coloring for visualization.
"""
struct ColoredNetwork{M<:AbstractLuxLayer}
    model::M
    layer_colors::Vector{Tuple{String, RGB{Float32}}}
    seed::UInt64
end

"""
    ColoredNetwork(model; seed=GAY_SEED)

Create a colored network for visualization.
"""
function ColoredNetwork(model::AbstractLuxLayer; seed::UInt64=GAY_SEED)
    colors = Tuple{String, RGB{Float32}}[]
    
    function walk_layers(m, prefix="")
        name = isempty(prefix) ? string(typeof(m).name.name) : prefix
        push!(colors, (name, color_layer(m; seed)))
        
        # If container layer, recurse
        if m isa Lux.AbstractLuxContainerLayer
            for fname in fieldnames(typeof(m))
                child = getfield(m, fname)
                if child isa AbstractLuxLayer
                    walk_layers(child, "$(name).$(fname)")
                end
            end
        end
    end
    
    walk_layers(model)
    ColoredNetwork(model, colors, seed)
end

"""
    render_network_graph(cn::ColoredNetwork) -> String

Render network as ANSI-colored ASCII graph.
"""
function render_network_graph(cn::ColoredNetwork)
    buf = IOBuffer()
    println(buf, "┌─────────────────────────────────────┐")
    println(buf, "│       Neural Network (SPI)          │")
    println(buf, "├─────────────────────────────────────┤")
    
    for (name, color) in cn.layer_colors
        r = round(Int, color.r * 255)
        g = round(Int, color.g * 255)
        b = round(Int, color.b * 255)
        
        # Colored layer name
        println(buf, "│ \e[38;2;$(r);$(g);$(b)m████\e[0m $(rpad(name, 30)) │")
    end
    
    println(buf, "└─────────────────────────────────────┘")
    String(take!(buf))
end

# ═══════════════════════════════════════════════════════════════════════════
# Training Loop with Color Tracking
# ═══════════════════════════════════════════════════════════════════════════

"""
    colored_training_step(model, ps, st, x, y, loss_fn; seed=GAY_SEED)

Execute one training step with gradient coloring for visualization.
Returns (new_ps, new_st, loss, gradient_colors).
"""
function colored_training_step(model, ps, st, x, y, loss_fn; 
                                seed::UInt64=GAY_SEED, lr::Float32=0.01f0)
    # Forward + backward
    (loss, st_new), grads = Zygote.withgradient(ps) do p
        y_pred, st_new = model(x, p, st)
        loss_fn(y_pred, y), st_new
    end
    
    # Color gradients
    grad_colors = color_parameters(grads[1]; seed)
    
    # Simple SGD update
    ps_new = Lux.fmap((p, g) -> p .- lr .* g, ps, grads[1])
    
    (ps=ps_new, st=st_new, loss=loss, gradient_colors=grad_colors)
end

end # module GayLuxExt
```

### Usage Example

```julia
using Lux, Random, Gay

# Define model
model = Chain(
    Dense(784 => 256, relu),
    Dense(256 => 128, relu),
    Dense(128 => 10)
)

# Create colored network visualization
cn = ColoredNetwork(model)
println(render_network_graph(cn))

# Setup
rng = Random.default_rng()
ps, st = Lux.setup(rng, model)

# Color all parameters (SPI: reproducible)
param_colors = color_parameters(ps)
for (path, cp) in param_colors
    println("$path: $(size(cp.values)) elements")
end

# Training with gradient coloring
x = randn(Float32, 784, 32)
y = randn(Float32, 10, 32)

result = colored_training_step(model, ps, st, x, y, Lux.MSELoss())
println("Loss: $(result.loss)")
```

---

## 9. Decapodes.jl Integration: Multiphysics PDE Coloring

Decapodes.jl combines Applied Category Theory (ACT) with Discrete Exterior Calculus (DEC) for multiphysics simulation. Gay.jl can provide SPI coloring for:

- **Mesh elements** (vertices, edges, triangles) - deterministic from geometry
- **DEC operators** (d, ⋆, Δ) - color by operator type
- **Physics fields** (temperature, velocity, pressure) - color by field value
- **Composition diagrams** - color by wiring structure

### SPI for Discrete Exterior Calculus

```julia
# In ext/GayDecapodesExt.jl
module GayDecapodesExt

using Decapodes, CombinatorialSpaces
using Gay: hash_color, hash_color_rgb, GAY_SEED, splitmix64

export color_mesh, color_field, color_operator, color_composition
export ColoredDecapode, render_physics_diagram

# ═══════════════════════════════════════════════════════════════════════════
# Mesh Element Coloring (SPI: same geometry → same colors)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_mesh(mesh::AbstractDeltaSet; seed=GAY_SEED)

Color mesh elements deterministically:
- Vertices by index
- Edges by (src, tgt) pair
- Triangles by vertex triple hash
"""
function color_mesh(mesh::AbstractDeltaSet; seed::UInt64=GAY_SEED)
    n_verts = nv(mesh)
    n_edges = ne(mesh)
    n_tris = ntriangles(mesh)
    
    # Vertex colors: simple index-based
    vert_colors = [hash_color_rgb(UInt64(i), seed) for i in 1:n_verts]
    
    # Edge colors: XOR of endpoints (symmetric)
    edge_colors = map(1:n_edges) do e
        s, t = src(mesh, e), tgt(mesh, e)
        idx = UInt64(s) ⊻ UInt64(t) ⊻ (UInt64(e) << 32)
        hash_color_rgb(idx, seed)
    end
    
    # Triangle colors: hash of sorted vertices
    tri_colors = map(1:n_tris) do t
        verts = triangle_vertices(mesh, t)
        sorted = sort(collect(verts))
        idx = reduce(⊻, (UInt64(v) << (i*16) for (i,v) in enumerate(sorted)))
        hash_color_rgb(idx, seed)
    end
    
    (vertices=vert_colors, edges=edge_colors, triangles=tri_colors)
end

# ═══════════════════════════════════════════════════════════════════════════
# DEC Operator Coloring
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_operator(op::Symbol; seed=GAY_SEED)

Color DEC operators by their type:
- d (exterior derivative): gradient hues
- ⋆ (Hodge star): complementary hues
- Δ (Laplacian): balanced hue
"""
function color_operator(op::Symbol; seed::UInt64=GAY_SEED)
    op_colors = Dict(
        :d₀ => HSL(30, 0.8, 0.5),   # Orange - 0-form derivative
        :d₁ => HSL(60, 0.8, 0.5),   # Yellow - 1-form derivative
        :d₂ => HSL(90, 0.8, 0.5),   # Green - 2-form derivative
        :⋆₀ => HSL(180, 0.8, 0.5),  # Cyan - 0-form Hodge
        :⋆₁ => HSL(210, 0.8, 0.5),  # Blue - 1-form Hodge
        :⋆₂ => HSL(240, 0.8, 0.5),  # Indigo - 2-form Hodge
        :Δ₀ => HSL(300, 0.8, 0.5),  # Magenta - 0-form Laplacian
        :Δ₁ => HSL(330, 0.8, 0.5),  # Pink - 1-form Laplacian
        :∧ => HSL(0, 0.8, 0.5),     # Red - wedge product
        :L => HSL(270, 0.8, 0.5),   # Purple - Lie derivative
    )
    
    base_color = get(op_colors, op, HSL(0, 0, 0.5))
    # Perturb by seed for SPI
    hue_offset = (splitmix64(seed ⊻ hash(op)) % 30) - 15
    convert(RGB, HSL(mod(base_color.h + hue_offset, 360), base_color.s, base_color.l))
end

# ═══════════════════════════════════════════════════════════════════════════
# Physics Field Coloring
# ═══════════════════════════════════════════════════════════════════════════

"""
    ColoredField

A scalar/vector field on a mesh with SPI colors.
"""
struct ColoredField{T}
    values::Vector{T}
    colors::Vector{RGB{Float32}}
    form_degree::Int  # 0, 1, or 2
    name::Symbol
end

"""
    color_field(values::Vector, form_degree::Int; seed=GAY_SEED, name=:field)

Color field values by magnitude, with SPI perturbation.
"""
function color_field(values::Vector{T}, form_degree::Int; 
                     seed::UInt64=GAY_SEED, name::Symbol=:field) where T
    # Normalize values
    vmin, vmax = extrema(values)
    range = vmax - vmin
    range = range > 0 ? range : one(T)
    
    # Base hue by form degree (SPI)
    base_hue = form_degree * 120.0  # 0=red, 1=green, 2=blue
    
    colors = map(enumerate(values)) do (i, v)
        normalized = (v - vmin) / range
        # Lightness varies with value, hue is fixed by form degree
        lightness = 0.3 + 0.4 * normalized
        # Small SPI perturbation per element
        hue_offset = (splitmix64(seed ⊻ UInt64(i)) % 20) - 10
        convert(RGB, HSL(mod(base_hue + hue_offset, 360), 0.7, lightness))
    end
    
    ColoredField(values, colors, form_degree, name)
end

# ═══════════════════════════════════════════════════════════════════════════
# Decapode Diagram Coloring
# ═══════════════════════════════════════════════════════════════════════════

"""
    ColoredDecapode

A Decapode diagram with SPI coloring for composition visualization.
"""
struct ColoredDecapode
    decapode::Any  # SummationDecapode or similar
    var_colors::Dict{Symbol, RGB{Float32}}
    op_colors::Dict{Int, RGB{Float32}}
    seed::UInt64
end

"""
    color_decapode(d::SummationDecapode; seed=GAY_SEED)

Color a Decapode diagram for visualization:
- Variables by name hash
- Operators by type
- Wires by connection structure
"""
function color_decapode(d; seed::UInt64=GAY_SEED)
    # Color variables by name
    var_colors = Dict{Symbol, RGB{Float32}}()
    for v in d[:name]
        var_colors[v] = hash_color_rgb(hash(v), seed)
    end
    
    # Color operations by type
    op_colors = Dict{Int, RGB{Float32}}()
    for (i, op) in enumerate(d[:op1])
        op_colors[i] = color_operator(op; seed)
    end
    
    ColoredDecapode(d, var_colors, op_colors, seed)
end

"""
    render_physics_diagram(cd::ColoredDecapode) -> String

Render Decapode as ANSI-colored diagram.
"""
function render_physics_diagram(cd::ColoredDecapode)
    buf = IOBuffer()
    println(buf, "╔════════════════════════════════════════╗")
    println(buf, "║         Decapode (SPI Colored)         ║")
    println(buf, "╠════════════════════════════════════════╣")
    
    # Variables
    println(buf, "║ Variables:                             ║")
    for (name, color) in cd.var_colors
        r = round(Int, color.r * 255)
        g = round(Int, color.g * 255)
        b = round(Int, color.b * 255)
        println(buf, "║   \e[38;2;$(r);$(g);$(b)m●\e[0m $(rpad(name, 35)) ║")
    end
    
    # Operators
    println(buf, "╠════════════════════════════════════════╣")
    println(buf, "║ Operators:                             ║")
    for (idx, color) in cd.op_colors
        r = round(Int, color.r * 255)
        g = round(Int, color.g * 255)
        b = round(Int, color.b * 255)
        op_name = string(cd.decapode[:op1][idx])
        println(buf, "║   \e[38;2;$(r);$(g);$(b)m▶\e[0m $(rpad(op_name, 35)) ║")
    end
    
    println(buf, "╚════════════════════════════════════════╝")
    String(take!(buf))
end

# ═══════════════════════════════════════════════════════════════════════════
# Composition Coloring
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_composition(d1::ColoredDecapode, d2::ColoredDecapode; seed=GAY_SEED)

When composing two Decapodes, shared variables get blended colors.
"""
function color_composition(d1::ColoredDecapode, d2::ColoredDecapode; 
                           seed::UInt64=GAY_SEED)
    shared_vars = intersect(keys(d1.var_colors), keys(d2.var_colors))
    
    blended = Dict{Symbol, RGB{Float32}}()
    for v in shared_vars
        c1, c2 = d1.var_colors[v], d2.var_colors[v]
        # Average the colors for shared variables
        blended[v] = RGB{Float32}(
            (c1.r + c2.r) / 2,
            (c1.g + c2.g) / 2,
            (c1.b + c2.b) / 2
        )
    end
    
    blended
end

end # module GayDecapodesExt
```

### Usage Example: Heat Equation on a Mesh

```julia
using Decapodes, CombinatorialSpaces, Gay

# Create a mesh
mesh = triangulated_grid(10, 10, 1.0, 1.0)

# Color mesh elements (SPI: reproducible)
mesh_colors = color_mesh(mesh)
println("Vertex 1 color: ", mesh_colors.vertices[1])
println("Edge 1 color: ", mesh_colors.edges[1])

# Define heat equation Decapode
heat = @decapode begin
    T::Form0
    ∂ₜ(T) == Δ₀(T)
end

# Color the diagram
cd = color_decapode(heat)
println(render_physics_diagram(cd))

# Color a temperature field
T_values = [sin(x) * cos(y) for (x,y) in mesh.vertices]
T_colored = color_field(T_values, 0; name=:Temperature)

# Animate with consistent SPI colors
for t in 1:100
    T_values .= evolve_heat(T_values, mesh, dt=0.01)
    T_colored = color_field(T_values, 0; name=:Temperature)
    # Each timestep, same spatial index → same hue family
end
```

---

## 10. Plasmo.jl Integration: OptiGraph SPI Coloring

Plasmo.jl provides graph-based optimization modeling with `OptiGraph`, `OptiNode`, and `OptiEdge`. Gay.jl can provide SPI coloring for:

- **OptiNodes** - Color by node index for consistent visualization
- **OptiEdges** - Color linking constraints by coupled node pairs
- **Partitions** - Color subgraphs for parallel decomposition
- **Solution values** - Color by variable value or dual

### SPI for Graph-Based Optimization

```julia
# In ext/GayPlasmoExt.jl
module GayPlasmoExt

using Plasmo: OptiGraph, OptiNode, OptiEdge, all_nodes, all_edges
using Plasmo: containing_optigraphs, local_edges, incident_edges
using Gay: hash_color, hash_color_rgb, GAY_SEED, splitmix64

export color_optigraph, color_partition, ColoredOptiGraph
export render_optigraph, solution_color_map

# ═══════════════════════════════════════════════════════════════════════════
# OptiNode/OptiEdge Coloring (SPI: same graph structure → same colors)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_node(node::OptiNode, graph::OptiGraph; seed=GAY_SEED) -> RGB

Deterministic color for an OptiNode based on its index in the graph.
"""
function color_node(node::OptiNode, graph::OptiGraph; seed::UInt64=GAY_SEED)
    nodes = collect(all_nodes(graph))
    idx = findfirst(==(node), nodes)
    idx === nothing && return hash_color_rgb(hash(node), seed)
    hash_color_rgb(UInt64(idx), seed)
end

"""
    color_edge(edge::OptiEdge, graph::OptiGraph; seed=GAY_SEED) -> RGB

Deterministic color for an OptiEdge based on its coupled nodes (XOR).
Symmetric: edge(n1, n2) == edge(n2, n1) in color.
"""
function color_edge(edge::OptiEdge, graph::OptiGraph; seed::UInt64=GAY_SEED)
    nodes = collect(all_nodes(graph))
    coupled = incident_edges(edge)
    if length(coupled) >= 2
        i1 = findfirst(==(coupled[1]), nodes)
        i2 = findfirst(==(coupled[2]), nodes)
        if i1 !== nothing && i2 !== nothing
            idx = UInt64(i1) ⊻ UInt64(i2)
            return hash_color_rgb(idx, seed)
        end
    end
    hash_color_rgb(hash(edge), seed)
end

# ═══════════════════════════════════════════════════════════════════════════
# Partition Coloring for Parallel Decomposition
# ═══════════════════════════════════════════════════════════════════════════

"""
    ColoredPartition

A partition of an OptiGraph with SPI colors for each subgraph.
Useful for visualizing decomposition for parallel solving.
"""
struct ColoredPartition
    graph::OptiGraph
    partition_ids::Vector{Int}  # Node index → partition ID
    partition_colors::Vector{RGB{Float32}}
    seed::UInt64
end

"""
    color_partition(graph::OptiGraph, partition_ids::Vector{Int}; seed=GAY_SEED)

Color a partitioned OptiGraph. Each partition gets a deterministic color.
"""
function color_partition(graph::OptiGraph, partition_ids::Vector{Int}; 
                         seed::UInt64=GAY_SEED)
    n_partitions = maximum(partition_ids)
    partition_colors = [hash_color_rgb(UInt64(p), seed) for p in 1:n_partitions]
    ColoredPartition(graph, partition_ids, partition_colors, seed)
end

"""
    color_partition(graph::OptiGraph, n_parts::Int; seed=GAY_SEED)

Partition graph into n_parts and color each partition.
Uses hypergraph partitioning via Plasmo's built-in methods.
"""
function color_partition(graph::OptiGraph, n_parts::Int; seed::UInt64=GAY_SEED)
    # Use Plasmo's partitioning
    partition = Plasmo.Partition(graph, n_parts)
    partition_ids = zeros(Int, length(all_nodes(graph)))
    
    for (p_idx, subgraph) in enumerate(partition.subgraphs)
        for node in all_nodes(subgraph)
            node_idx = findfirst(==(node), collect(all_nodes(graph)))
            if node_idx !== nothing
                partition_ids[node_idx] = p_idx
            end
        end
    end
    
    color_partition(graph, partition_ids; seed)
end

# ═══════════════════════════════════════════════════════════════════════════
# Full OptiGraph Coloring
# ═══════════════════════════════════════════════════════════════════════════

"""
    ColoredOptiGraph

An OptiGraph with SPI coloring for visualization.
"""
struct ColoredOptiGraph
    graph::OptiGraph
    node_colors::Dict{OptiNode, RGB{Float32}}
    edge_colors::Dict{OptiEdge, RGB{Float32}}
    seed::UInt64
end

"""
    color_optigraph(graph::OptiGraph; seed=GAY_SEED) -> ColoredOptiGraph

Color all nodes and edges in an OptiGraph deterministically.
"""
function color_optigraph(graph::OptiGraph; seed::UInt64=GAY_SEED)
    node_colors = Dict{OptiNode, RGB{Float32}}()
    edge_colors = Dict{OptiEdge, RGB{Float32}}()
    
    for node in all_nodes(graph)
        node_colors[node] = color_node(node, graph; seed)
    end
    
    for edge in all_edges(graph)
        edge_colors[edge] = color_edge(edge, graph; seed)
    end
    
    ColoredOptiGraph(graph, node_colors, edge_colors, seed)
end

# ═══════════════════════════════════════════════════════════════════════════
# Solution Coloring
# ═══════════════════════════════════════════════════════════════════════════

"""
    solution_color_map(graph::OptiGraph; seed=GAY_SEED, by=:objective)

Color nodes by solution values after optimization.
- by=:objective → color by objective contribution
- by=:dual → color by dual values (shadow prices)
- by=:slack → color by constraint slack
"""
function solution_color_map(graph::OptiGraph; seed::UInt64=GAY_SEED, by::Symbol=:objective)
    node_colors = Dict{OptiNode, RGB{Float32}}()
    
    values = Float64[]
    nodes = collect(all_nodes(graph))
    
    for node in nodes
        val = if by == :objective
            objective_value(node)
        elseif by == :dual
            # Sum of dual values for node constraints
            sum(dual.(all_constraints(node)); init=0.0)
        else
            0.0
        end
        push!(values, val)
    end
    
    # Normalize and color
    vmin, vmax = extrema(values)
    range = vmax - vmin
    range = range > 0 ? range : 1.0
    
    for (i, node) in enumerate(nodes)
        normalized = (values[i] - vmin) / range
        # Low value = blue, high value = red
        hue = (1.0 - normalized) * 240.0
        node_colors[node] = convert(RGB, HSL(hue, 0.7, 0.5))
    end
    
    node_colors
end

# ═══════════════════════════════════════════════════════════════════════════
# Visualization
# ═══════════════════════════════════════════════════════════════════════════

"""
    render_optigraph(cg::ColoredOptiGraph) -> String

Render OptiGraph as ANSI-colored ASCII diagram.
"""
function render_optigraph(cg::ColoredOptiGraph)
    buf = IOBuffer()
    println(buf, "╔════════════════════════════════════════════╗")
    println(buf, "║          OptiGraph (SPI Colored)           ║")
    println(buf, "╠════════════════════════════════════════════╣")
    
    # Nodes
    println(buf, "║ Nodes:                                     ║")
    for (node, color) in cg.node_colors
        r = round(Int, color.r * 255)
        g = round(Int, color.g * 255)
        b = round(Int, color.b * 255)
        println(buf, "║   \e[38;2;$(r);$(g);$(b)m●\e[0m $(rpad(string(node), 37)) ║")
    end
    
    # Edges (linking constraints)
    println(buf, "╠════════════════════════════════════════════╣")
    println(buf, "║ Edges (Linking Constraints):               ║")
    for (edge, color) in cg.edge_colors
        r = round(Int, color.r * 255)
        g = round(Int, color.g * 255)
        b = round(Int, color.b * 255)
        println(buf, "║   \e[38;2;$(r);$(g);$(b)m━━━\e[0m $(rpad(string(edge), 35)) ║")
    end
    
    println(buf, "╚════════════════════════════════════════════╝")
    String(take!(buf))
end

end # module GayPlasmoExt
```

### Usage Example: Supply Chain Optimization

```julia
using Plasmo, Ipopt, Gay

# Create supply chain OptiGraph
graph = OptiGraph()

# Add nodes for facilities
@optinode(graph, warehouse)
@optinode(graph, factory1)
@optinode(graph, factory2)
@optinode(graph, retail)

# Variables and constraints per node
@variable(warehouse, 0 <= inventory <= 1000)
@variable(factory1, 0 <= production1 <= 500)
@variable(factory2, 0 <= production2 <= 500)
@variable(retail, 0 <= sales <= 800)

# Linking constraints (supply chain flow)
@linkconstraint(graph, warehouse[:inventory] >= factory1[:production1] + factory2[:production2])
@linkconstraint(graph, retail[:sales] <= warehouse[:inventory])

# Objective
@objective(graph, Max, retail[:sales] - 0.1 * warehouse[:inventory])

# Color the graph (SPI: reproducible)
cg = color_optigraph(graph)
println(render_optigraph(cg))

# Solve
set_optimizer(graph, Ipopt.Optimizer)
optimize!(graph)

# Color by solution values
sol_colors = solution_color_map(graph; by=:objective)
for (node, color) in sol_colors
    println("$(node): $(color)")
end
```

---

## 11. CombinatorialSpaces.jl Integration: Complete SPI Examples

Gay.jl provides SPI coloring for **every** CombinatorialSpaces.jl example, ensuring associativity of parallel operations through deterministic color assignment.

### SPI Associativity Guarantee

```
Parallel Color Invariant: For any associative operation ⊕ on colored elements,

    color(a ⊕ b) ⊕ color(c) == color(a) ⊕ (color(b ⊕ c))

This is guaranteed by Gay.jl's O(1) hash_color function:
- Each mesh element gets a unique, deterministic color
- Colors are independent of computation order
- Parallel reductions produce identical results
```

### 11.1 Simplicial Sets (DeltaSet1D, DeltaSet2D)

```julia
# In ext/GayCombinatorialSpacesExt.jl
module GayCombinatorialSpacesExt

using CombinatorialSpaces: DeltaSet1D, DeltaSet2D, EmbeddedDeltaSet2D
using CombinatorialSpaces: nv, ne, ntriangles, ∂, triangle_vertices
using CombinatorialSpaces: DualSimplicalSet, subdivide_duals!
using CombinatorialSpaces.DiscreteExteriorCalculus: d, ⋆, Δ, ♭, ♯
using Gay: hash_color, hash_color_rgb, GAY_SEED, splitmix64, xor_fingerprint

export color_deltaset, color_dual, ColoredSimplicialSet
export spi_verify_parallel, associative_color_reduce

# ═══════════════════════════════════════════════════════════════════════════
# Example 1: 1D Delta Set (from docs: line segment subdivision)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_deltaset_1d(ds::DeltaSet1D; seed=GAY_SEED)

Color a 1D delta set with SPI colors.

From CombinatorialSpaces docs:
```julia
ds = DeltaSet1D()
add_vertices!(ds, 4)
add_edge!(ds, 2, 1)  # E1: 2→1
add_edge!(ds, 3, 2)  # E2: 3→2
add_edge!(ds, 4, 2)  # E3: 4→2
```

Each vertex gets color(i, seed), each edge gets color(src ⊻ tgt, seed).
"""
function color_deltaset_1d(ds::DeltaSet1D; seed::UInt64=GAY_SEED)
    n_v = nv(ds)
    n_e = ne(ds)
    
    # Vertex colors: O(1) per vertex
    vertex_colors = [hash_color_rgb(UInt64(v), seed) for v in 1:n_v]
    
    # Edge colors: XOR of boundary vertices (associative!)
    edge_colors = map(1:n_e) do e
        v0, v1 = ∂(0, ds, e), ∂(1, ds, e)  # ∂v0, ∂v1
        idx = UInt64(v0) ⊻ UInt64(v1)
        hash_color_rgb(idx, seed)
    end
    
    (vertices=vertex_colors, edges=edge_colors)
end

# ═══════════════════════════════════════════════════════════════════════════
# Example 2: 2D Delta Set (from docs: triangulated square)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_deltaset_2d(ds::DeltaSet2D; seed=GAY_SEED)

Color a 2D delta set with SPI colors.

From CombinatorialSpaces docs (triangulated commutative square):
```julia
ds = DeltaSet2D()
add_vertices!(ds, 4)
glue_triangle!(ds, 1, 2, 3)
glue_triangle!(ds, 1, 3, 4)
```

Triangle colors use XOR of sorted vertex indices (associative, commutative).
"""
function color_deltaset_2d(ds::DeltaSet2D; seed::UInt64=GAY_SEED)
    # Vertices and edges
    base = color_deltaset_1d(ds; seed)
    
    # Triangle colors: XOR of sorted vertices
    n_tri = ntriangles(ds)
    tri_colors = map(1:n_tri) do t
        verts = triangle_vertices(ds, t)
        sorted = sort(collect(verts))
        # XOR is associative: (a ⊻ b) ⊻ c == a ⊻ (b ⊻ c)
        idx = reduce(⊻, UInt64.(sorted))
        hash_color_rgb(idx, seed)
    end
    
    (vertices=base.vertices, edges=base.edges, triangles=tri_colors)
end

# ═══════════════════════════════════════════════════════════════════════════
# Example 3: Embedded Delta Set with Dual Complex (from Meshes docs)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_embedded_dual(ds::EmbeddedDeltaSet2D; seed=GAY_SEED)

Color an embedded delta set AND its dual complex.

From CombinatorialSpaces Meshes docs:
```julia
ds = EmbeddedDeltaSet2D("mesh.obj")
dual = DualSimplicialSet(ds)
subdivide_duals!(dual, Barycenter())
```

Dual vertices (triangle centroids) get colors from primal triangle.
Dual edges get colors from primal edge XOR.
"""
function color_embedded_dual(ds::EmbeddedDeltaSet2D; seed::UInt64=GAY_SEED)
    primal = color_deltaset_2d(ds; seed)
    
    # Dual complex: dual vertex i corresponds to primal triangle i
    dual_vertex_colors = primal.triangles
    
    # Dual edges: connect dual vertices across primal edges
    n_e = ne(ds)
    dual_edge_colors = map(1:n_e) do e
        # Dual edge crosses primal edge
        # Color by primal edge color (already XOR-based)
        primal.edges[e]
    end
    
    (primal=primal, 
     dual_vertices=dual_vertex_colors, 
     dual_edges=dual_edge_colors)
end

# ═══════════════════════════════════════════════════════════════════════════
# Example 4: Poisson Equation Multigrid (from grid_laplace docs)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_multigrid_levels(levels::Vector; seed=GAY_SEED)

Color multigrid hierarchy for Poisson equation.

From CombinatorialSpaces grid_laplace docs:
```julia
# Coarsest level: 2 vertices, 1 edge
coarse = DeltaSet1D()
add_vertices!(coarse, 2)
add_edge!(coarse, 2, 1)

# Repeated subdivisions create multigrid hierarchy
levels = repeated_subdivisions(coarse, k)
```

Each level gets consistent colors relative to parent level.
"""
function color_multigrid_levels(levels::Vector; seed::UInt64=GAY_SEED)
    colored_levels = []
    
    for (level_idx, ds) in enumerate(levels)
        # Each level uses seed XOR'd with level index
        level_seed = seed ⊻ UInt64(level_idx * 0x9e3779b97f4a7c15)
        colors = color_deltaset_1d(ds; seed=level_seed)
        
        push!(colored_levels, (
            level=level_idx,
            seed=level_seed,
            colors=colors,
            # Fingerprint for SPI verification
            fingerprint=xor_fingerprint_vertices(colors.vertices)
        ))
    end
    
    colored_levels
end

# Helper for fingerprinting
function xor_fingerprint_vertices(colors::Vector{RGB{Float32}})
    fp = UInt64(0)
    for c in colors
        r_bits = reinterpret(UInt32, Float32(c.r))
        g_bits = reinterpret(UInt32, Float32(c.g))
        b_bits = reinterpret(UInt32, Float32(c.b))
        fp ⊻= UInt64(r_bits) | (UInt64(g_bits) << 24) | (UInt64(b_bits) << 48)
    end
    fp
end

# ═══════════════════════════════════════════════════════════════════════════
# Example 5: 2D Poisson on Triangular Grid (from grid_laplace docs)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_poisson_2d(ds::DeltaSet2D, u::Vector; seed=GAY_SEED)

Color solution of 2D Poisson equation on triangular mesh.

From CombinatorialSpaces docs:
```julia
# Triangular mesh on unit square
ds = triangulated_grid(n, n, 1.0, 1.0)
L = Δ(Val{0}, ds)  # Laplacian
u = L \\ b          # Solve Poisson
```

Solution values get hue from mesh position, lightness from value.
"""
function color_poisson_2d(ds::DeltaSet2D, u::Vector{T}; 
                          seed::UInt64=GAY_SEED) where T
    n_v = nv(ds)
    @assert length(u) == n_v "Solution vector must match vertex count"
    
    # Normalize solution
    umin, umax = extrema(u)
    range = umax - umin
    range = range > 0 ? range : one(T)
    
    colors = map(1:n_v) do v
        # Base hue from vertex position (SPI)
        base_color = hash_color_rgb(UInt64(v), seed)
        base_hsl = convert(HSL, base_color)
        
        # Lightness from solution value
        normalized = (u[v] - umin) / range
        lightness = 0.2 + 0.6 * normalized
        
        convert(RGB, HSL(base_hsl.h, 0.8, lightness))
    end
    
    (vertices=colors, solution=u)
end

# ═══════════════════════════════════════════════════════════════════════════
# Example 6: Euler Equations (from euler docs)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_euler_flow(ds::EmbeddedDeltaSet2D, u_flat::Vector; seed=GAY_SEED)

Color velocity field from Euler equations.

From CombinatorialSpaces euler docs:
```julia
# Velocity as 1-form (flattened vector field)
u_flat = ♭(ds, velocity_field)

# Self-advection term
advection = ℒ(ds, u_flat, u_flat) - 0.5 * d(ds, interior_product(ds, u_flat, u_flat))
```

Edge colors encode flow direction and magnitude.
"""
function color_euler_flow(ds::EmbeddedDeltaSet2D, u_flat::Vector{T};
                          seed::UInt64=GAY_SEED) where T
    n_e = ne(ds)
    @assert length(u_flat) == n_e "1-form must have one value per edge"
    
    # Normalize flow values
    umax = maximum(abs, u_flat)
    umax = umax > 0 ? umax : one(T)
    
    edge_colors = map(1:n_e) do e
        # Base hue from edge position (SPI)
        v0, v1 = ∂(0, ds, e), ∂(1, ds, e)
        idx = UInt64(v0) ⊻ UInt64(v1)
        base_color = hash_color_rgb(idx, seed)
        base_hsl = convert(HSL, base_color)
        
        # Saturation from magnitude, hue shift from sign
        normalized = u_flat[e] / umax
        saturation = abs(normalized)
        hue_shift = normalized > 0 ? 0.0 : 180.0  # Flip hue for negative flow
        
        convert(RGB, HSL(mod(base_hsl.h + hue_shift, 360), saturation, 0.5))
    end
    
    (edges=edge_colors, flow=u_flat)
end

# ═══════════════════════════════════════════════════════════════════════════
# Example 7: DEC Operators (from discrete_exterior_calculus docs)
# ═══════════════════════════════════════════════════════════════════════════

"""
    color_dec_operator(op::Symbol, ds; seed=GAY_SEED)

Color discrete exterior calculus operator application.

From CombinatorialSpaces DEC docs, operators include:
- d: exterior derivative (0→1, 1→2 forms)
- ⋆: Hodge star (k → n-k forms)
- Δ: Laplacian (k → k forms)
- ♭: flat (vectors → 1-forms)
- ♯: sharp (1-forms → vectors)
"""
function color_dec_operator(op::Symbol, ds; seed::UInt64=GAY_SEED)
    # Operator type determines base hue family
    op_hues = Dict(
        :d0 => 30.0,   # Orange: 0-form exterior derivative
        :d1 => 60.0,   # Yellow: 1-form exterior derivative
        :star0 => 180.0, # Cyan: 0-form Hodge star
        :star1 => 210.0, # Blue: 1-form Hodge star
        :star2 => 240.0, # Indigo: 2-form Hodge star
        :laplacian => 300.0, # Magenta: Laplacian
        :flat => 120.0,  # Green: flat
        :sharp => 150.0, # Teal: sharp
    )
    
    base_hue = get(op_hues, op, 0.0)
    
    # Color matrix entries based on row/column indices
    function color_matrix_entry(i::Int, j::Int)
        idx = UInt64(i) ⊻ (UInt64(j) << 32)
        h = base_hue + (splitmix64(seed ⊻ idx) % 30) - 15
        convert(RGB, HSL(mod(h, 360), 0.7, 0.5))
    end
end

# ═══════════════════════════════════════════════════════════════════════════
# SPI Verification: Parallel Associativity Check
# ═══════════════════════════════════════════════════════════════════════════

"""
    spi_verify_parallel(ds, seed; n_threads=Threads.nthreads())

Verify SPI holds under parallel execution.

The key invariant: coloring is associative under parallel reduction.
For any partition P1, P2 of mesh elements:
    xor_fingerprint(color(P1) ∪ color(P2)) == 
    xor_fingerprint(color(P2) ∪ color(P1))
"""
function spi_verify_parallel(ds::DeltaSet2D, seed::UInt64=GAY_SEED; 
                             n_threads::Int=Threads.nthreads())
    n_v = nv(ds)
    
    # Parallel coloring with different thread assignments
    results = Vector{UInt64}(undef, n_threads)
    
    Threads.@threads for tid in 1:n_threads
        # Each thread colors a subset
        chunk_size = cld(n_v, n_threads)
        start_idx = (tid - 1) * chunk_size + 1
        end_idx = min(tid * chunk_size, n_v)
        
        local_fp = UInt64(0)
        for v in start_idx:end_idx
            c = hash_color_rgb(UInt64(v), seed)
            r_bits = reinterpret(UInt32, Float32(c.r))
            g_bits = reinterpret(UInt32, Float32(c.g))
            b_bits = reinterpret(UInt32, Float32(c.b))
            local_fp ⊻= UInt64(r_bits) | (UInt64(g_bits) << 24) | (UInt64(b_bits) << 48)
        end
        results[tid] = local_fp
    end
    
    # XOR is associative: final result is order-independent
    parallel_fp = reduce(⊻, results)
    
    # Sequential reference
    sequential_fp = UInt64(0)
    for v in 1:n_v
        c = hash_color_rgb(UInt64(v), seed)
        r_bits = reinterpret(UInt32, Float32(c.r))
        g_bits = reinterpret(UInt32, Float32(c.g))
        b_bits = reinterpret(UInt32, Float32(c.b))
        sequential_fp ⊻= UInt64(r_bits) | (UInt64(g_bits) << 24) | (UInt64(b_bits) << 48)
    end
    
    spi_holds = parallel_fp == sequential_fp
    
    (spi_verified=spi_holds, 
     parallel_fingerprint=parallel_fp, 
     sequential_fingerprint=sequential_fp)
end

"""
    associative_color_reduce(elements, op::Function; seed=GAY_SEED)

Reduce colored elements with an associative operation.
Verifies that (a ⊕ b) ⊕ c == a ⊕ (b ⊕ c) for colors.
"""
function associative_color_reduce(elements::Vector, op::Function; 
                                  seed::UInt64=GAY_SEED)
    colors = [hash_color_rgb(hash(e), seed) for e in elements]
    
    # Left-associative reduction
    left_result = reduce((a, b) -> op(a, b), colors)
    
    # Right-associative reduction (via foldr)
    right_result = foldr((a, b) -> op(a, b), colors)
    
    # For truly associative ops, these should match
    (left=left_result, right=right_result, 
     associative=(left_result == right_result))
end

end # module GayCombinatorialSpacesExt
```

### Complete Example: Heat Equation with SPI Verification

```julia
using CombinatorialSpaces, Gay, LinearAlgebra

# Create triangular mesh (from docs)
ds = triangulated_grid(20, 20, 1.0, 1.0)
dual = DualSimplicialSet(ds)
subdivide_duals!(dual, Barycenter())

# Color the mesh (SPI: same mesh → same colors always)
mesh_colors = color_deltaset_2d(ds)
println("Vertices: ", length(mesh_colors.vertices))
println("Edges: ", length(mesh_colors.edges))
println("Triangles: ", length(mesh_colors.triangles))

# Verify SPI under parallel execution
spi_result = spi_verify_parallel(ds, GAY_SEED)
println("SPI Verified: ", spi_result.spi_verified)
println("Fingerprint: ", string(spi_result.parallel_fingerprint, base=16))

# Build Laplacian and solve Poisson
L = Δ(Val{0}, ds)
b = randn(nv(ds))
b[1] = 0.0  # Dirichlet BC
b[end] = 0.0

u = L \ b

# Color solution (SPI: same solution → same visualization)
sol_colors = color_poisson_2d(ds, u)

# Verify associativity of color reduction
vertices = collect(1:nv(ds))
assoc_result = associative_color_reduce(vertices, 
    (c1, c2) -> RGB{Float32}((c1.r + c2.r)/2, (c1.g + c2.g)/2, (c1.b + c2.b)/2))
println("Color reduction associative: ", assoc_result.associative)
```

---

## 12. Dependency Changes

```toml
# Project.toml additions for v0.2.0
[deps]
ACSets = "227ef7b5-1206-438b-ac65-934d6da304b8"
Catlab = "134e5e36-593f-5add-ad60-77f754baafbe"
AlgebraicRewriting = "725a01d3-f174-5bbd-84e1-b9417bad95d9"
TreeSitter = "..."  # Julia tree-sitter bindings

[weakdeps]
Rimu = "c53c40cc-bd84-11e9-2cf4-a9c75186032b"
Lux = "b2108857-7c20-44ae-9111-449ecde12c47"
Zygote = "e88e6eb3-aa80-5325-afca-941959d7151f"
Decapodes = "83a53e14-5b26-11ed-1509-bf4f74675ab6"
CombinatorialSpaces = "b1c52339-7909-45ad-8b6a-6e388f7c67f2"
Plasmo = "d3f7391f-f14a-50cc-bbe4-76a32d1bad3c"

[extensions]
GayRimuExt = "Rimu"
GayLuxExt = ["Lux", "Zygote"]
GayDecapodesExt = ["Decapodes", "CombinatorialSpaces"]
GayPlasmoExt = "Plasmo"
GayCombinatorialSpacesExt = "CombinatorialSpaces"
```

---

## 13. Migration Guide

```julia
# v0.1.0 → v0.2.0 changes

# Old: Direct hash_color usage
color = hash_color(42)

# New: Also valid, but prefer protocol for extensibility
color = colorize(my_object, GAY_SEED)

# New: ACSet integration
g = ColoredGraph()
add_vertices!(g, 10)
gay_color_acset!(g)  # All vertices now have deterministic colors

# New: ColorExperience wrapper
items = ["apple", "banana", "cherry"]
for (item, color, idx) in ColorExperience(items, GAY_SEED)
    println("$item is colored $(color)")
end
```

---

## Summary: v0.2.0 Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Gay.jl v0.2.0                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │ kernels.jl  │ │  acsets.jl  │ │treesitter.jl│ │   rimu.jl   │           │
│  │ O(1) hash   │ │  Catlab +   │ │  AST color  │ │ FCIQMC viz  │           │
│  │ GPU/SPMD    │ │  ACSets     │ │  analysis   │ │ Fock states │           │
│  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘ └──────┬──────┘           │
│         │               │               │               │                   │
│         └───────────────┴───────┬───────┴───────────────┘                   │
│                                 │                                           │
│                        ┌────────▼────────┐                                  │
│                        │   protocol.jl   │                                  │
│                        │   Colorable     │                                  │
│                        │ ColorExperience │                                  │
│                        └────────┬────────┘                                  │
│                                 │                                           │
│  ┌──────────────────────────────┼──────────────────────────────────────┐   │
│  │          Universal Color Experience Integration                      │   │
│  │  • Any collection → colored view                                    │   │
│  │  • Any ACSet → deterministic graph coloring                         │   │
│  │  • Any AST → syntax-aware coloring                                  │   │
│  │  • Any QUIC path → probe coloring                                   │   │
│  │  • Any Fock state → QMC walker coloring                             │   │
│  │  • Any FCIQMC trajectory → temporal evolution visualization         │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Implementation Priority

1. **High**: `protocol.jl` - Universal Colorable trait
2. **High**: `acsets.jl` - ACSets/Catlab integration  
3. **High**: `rimu.jl` - Rimu.jl FCIQMC/Fock state coloring
4. **Medium**: `treesitter.jl` - Code color analysis
5. **Medium**: AlgebraicRewriting color constraints
6. **Low**: Full category-theoretic color functor formalization
